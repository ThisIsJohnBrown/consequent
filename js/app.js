// Generated by CoffeeScript 1.8.0
var SoundApp, soundApp;

SoundApp = function(sketch) {
  this.mute = false;
  this.dataWatcher = null;
  this.visualizer = null;
  this.gibber = sketch.Gibber;
  this.baseBPM = 120;
  this.fftSize = 32;
  sketch.setup = (function(_this) {
    return function() {
      var bassDelayObj, bassObj, bassVisObj, hatVisObj, i, kickVisObj, len, melodyObj, snareVisObj, synMelody, _i;
      _this.dataWatcher = new UncontextDataWatcher(sketch);
      console.log(_this.dataWatcher);
      sketch.createCanvas(sketch.windowWidth, sketch.windowHeight);
      $("#defaultCanvas").detach();
      _this.visualizer = new Visualizer(sketch);
      window.visualizer = _this.visualizer;
      console.log(_this.visualizer);
      window.gibber = _this.gibber;
      console.log(_this.gibber);
      _this.kick = sketch.createEDrum("x...x...");
      _this.snare = sketch.createEDrum("..o...o.");
      _this.hat = sketch.createEDrum("--------");
      bassObj = _this.gibber.Presets.Mono.dark;
      bassObj.octave = -1;
      bassObj.amp = 1;
      _this.bass = sketch.createMono(bassObj);
      _this.bass.note.seq([0, 0, 1, 0, 0, 0, 2, 1], [1 / 8]);
      synMelody = _this.gibber.Presets.Mono.dark2;
      synMelody.octave = -1;
      synMelody.amp = .8;
      synMelody.attack = .5;
      synMelody.decay = 2;
      _this.synMelody = sketch.createMono(synMelody);
      _this.synMelody.note.seq([0, 0, 2, 3, 4], [1, 1, 1, 1 / 2, 1 / 2]);
      melodyObj = {
        attack: 0.05,
        decay: .85,
        amp: 0.05
      };
      _this.melody = sketch.createSynth(melodyObj);
      _this.melody.note.seq([0, 2, 0, 2, 0].rnd(), [1 / 16]);
      bassDelayObj = {
        feedback: .2,
        wet: .5,
        dry: 1
      };
      _this.bassDelay = sketch.createDelay(bassDelayObj);
      _this.bass.fx.add(bassDelay);
      _this.gibber.scale.root.seq(['c4', 'ab3', 'bb3'], [4, 2, 2]);
      _this.gibber.scale.mode.seq(['Minor'], [8]);
      _this.FFT = _this.gibber.Analysis.FFT(_this.fftSize);
      i = 0;
      _this.kickFollow = _this.gibber.Analysis.Follow(_this.kick);
      _this.snareFollow = _this.gibber.Analysis.Follow(_this.snare);
      _this.hatFollow = _this.gibber.Analysis.Follow(_this.hat);
      _this.bassFollow = _this.gibber.Analysis.Follow(_this.bass);
      kickVisObj = {
        color: 0xff9900,
        opacity: 0.8
      };
      _this.kickVis = sketch.createVisual(_this.kick, _this.kickFollow, kickVisObj, ++i);
      snareVisObj = {
        color: 0x00ff99,
        opacity: 0.8
      };
      _this.snareVis = sketch.createVisual(_this.snare, _this.snareFollow, snareVisObj, ++i);
      hatVisObj = {
        color: 0x0099ff,
        opacity: 0.8
      };
      _this.hatVis = sketch.createVisual(_this.hat, _this.hatFollow, hatVisObj, ++i);
      bassVisObj = {
        color: 0x9900FF,
        opacity: 0.8
      };
      _this.bassVis = sketch.createVisual(_this.bass, _this.bassFollow, bassVisObj, ++i);
      i = 0;
      _this.cubes = [];
      len = (_this.fftSize / 4) - 1;
      for (i = _i = 0; 0 <= len ? _i <= len : _i >= len; i = 0 <= len ? ++_i : --_i) {
        _this.cubes.push(sketch.createCube({
          color: Math.random() * 0xffffff,
          opacity: 0.8
        }, i));
      }
    };
  })(this);
  sketch.createCrush = (function(_this) {
    return function() {
      var crush;
      crush = _this.gibber.FX.Crush({
        bitDepth: 4
      });
      crush.bitDepth.seq([2, 4, 8, 6], 1 / 2);
      return crush;
    };
  })(this);
  sketch.createEDrum = (function(_this) {
    return function(pattern) {
      var drum;
      drum = _this.gibber.Percussion.EDrums(pattern);
      return drum;
    };
  })(this);
  sketch.createBass = (function(_this) {
    return function(initObj) {
      var bass;
      bass = _this.gibber.Synths.FM(initObj);
      return bass;
    };
  })(this);
  sketch.createSine = (function(_this) {
    return function() {
      var sine, tremolo;
      sine = _this.gibber.Oscillators.Sine();
      sine.frequency.seq([440, 220], [1 / 4, 1 / 8, 1 / 16]);
      tremolo = _this.gibber.FX.Tremolo({
        amp: 1,
        frequency: .1
      });
      sine.fx.add(tremolo);
      return sine;
    };
  })(this);
  sketch.createPWM = (function(_this) {
    return function() {
      var pwm;
      pwm = _this.gibber.Oscillators.PWM({
        pulsewidth: _this.gibber.Binops.Add(.5, _this.gibber.Oscillators.Sine(0.1, 100)._)
      });
      return pwm;
    };
  })(this);
  sketch.createSynth = (function(_this) {
    return function(initObj) {
      var synth;
      synth = _this.gibber.Synths.Synth(initObj);
      return synth;
    };
  })(this);
  sketch.createSynth2 = (function(_this) {
    return function(initObj) {
      var synth2;
      synth2 = _this.gibber.Synths.Synth2(initObj);
      return synth2;
    };
  })(this);
  sketch.createFM = (function(_this) {
    return function(initObj) {
      var fm;
      fm = _this.gibber.Synths.FM(initObj);
      return fm;
    };
  })(this);
  sketch.createMono = (function(_this) {
    return function(initObj) {
      var mono;
      mono = _this.gibber.Synths.Mono(initObj);
      return mono;
    };
  })(this);
  sketch.createSchizo = (function(_this) {
    return function(initObj) {
      var schizo;
      schizo = _this.gibber.FX.Schizo(initObj);
      return schizo;
    };
  })(this);
  sketch.createDelay = (function(_this) {
    return function(initObj) {
      var delay;
      delay = _this.gibber.FX.Delay(initObj);
      return delay;
    };
  })(this);
  sketch.createReverb = (function(_this) {
    return function(initObj) {
      var reverb;
      reverb = _this.gibber.FX.Reverb(initObj);
      return reverb;
    };
  })(this);
  sketch.onDataChange = (function(_this) {
    return function(data) {
      var bassAmp, bassDelayfeedback, bassFrequency, bpm, hatAmp, melodyAmp, melodyAttack, melodyOctave, snareAmp, synAmp, synPan;
      _this.data = data;
      bassAmp = _this.data.b[0];
      bassFrequency = _this.data.b[1] * 440;
      TweenLite.to(_this.bass, .5, {
        amp: bassAmp,
        frequency: bassFrequency
      });
      bassDelayfeedback = _this.data.b[0];
      TweenLite.to(_this.bass.fx, 1, {
        feedback: bassDelayfeedback
      });
      snareAmp = _this.data.d;
      TweenLite.to(_this.snare, 1, {
        amp: snareAmp
      });
      hatAmp = _this.data.c;
      if (_this.data.a[0] < .3) {
        _this.hat.seq.durations = [1 / 8];
      } else if (_this.data.a[0] >= .3 && _this.data.a[0] < .6) {
        _this.hat.seq.durations = [1 / 16];
      } else {
        _this.hat.seq.durations = [1 / 32];
      }
      TweenLite.to(_this.hat, 3, {
        amp: hatAmp
      });
      melodyAmp = _this.data.b[1] / 50;
      melodyAttack = Math.max(0.05, _this.data.b[0]);
      melodyOctave = Math.floor((_this.data.f * 10) / 3);
      _this.melody.octave = melodyOctave;
      TweenLite.to(_this.melody, .2, {
        amp: melodyAmp
      });
      bpm = _this.baseBPM + _this.data.d * 10 - data.e * 10;
      TweenLite.to(_this.gibber.Clock, 1, {
        baseBPM: baseBPM,
        bpm: bpm
      });
      synAmp = Math.min(_this.data.f, 1);
      synPan = _this.data.f * 2 - 1;
      return TweenLite.to(_this.synMelody, .5, {
        amp: synAmp,
        pan: synPan
      });
    };
  })(this);
  sketch.draw = (function(_this) {
    return function() {
      var barColor, barHeight, cube, i, numBars, value, _i, _len, _ref;
      _this.kickVis.scale.z = Math.max(.01, _this.kickFollow.getValue() * 100);
      _this.snareVis.scale.z = Math.max(.01, _this.snareFollow.getValue() * 100);
      _this.hatVis.scale.z = Math.max(.01, _this.hatFollow.getValue() * 100);
      _this.bassVis.scale.z = Math.max(.01, _this.bassFollow.getValue() * 10);
      numBars = _this.fftSize / 2;
      barHeight = 100;
      barColor = null;
      value = null;
      i = 0;
      _ref = _this.cubes;
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        cube = _ref[i];
        value = _this.FFT[i].value / 255;
        cube.scale.z = value * 10;
      }
    };
  })(this);
  sketch.keyPressed = (function(_this) {
    return function(e) {
      console.log('key code :: ', e.keyCode);
      switch (e.keyCode) {
        case 32:
          _this.mute = !_this.mute;
          if (_this.mute) {
            _this.gibber.Master.amp = 0;
            return sketch.noLoop();
          } else {
            _this.gibber.Master.amp = 1;
            return sketch.loop();
          }
          break;
        case 16:
          return console.log(_this.data.e);
      }
    };
  })(this);
};

soundApp = new p5(SoundApp);
